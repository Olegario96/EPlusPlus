import os
import subprocess
import multiprocessing

##
## @brief      Class for process manager. This class is responsible for create
##             tasks and processes to execute each task. The main responsibility
##             of this class is to create a number of subprocess equal to 
##             the number of the cores of the current machine. After that, each
##             process will receive a task to run inside the energy plus. Then
##             it will wait all processes finish. If not tasks were been
##             concluded, then will repeat the processes until no more tasks
##             remaing. The os import is necessary to list files in directory.
##             The subprocess is used to create new subprocess and the
##             multiprocessing is used to get the number of cpu's in the 
##             currente PC.
##
class ProcessManager(object):
	def __init__(self):
		super(ProcessManager, self).__init__()
		self.numCores = multiprocessing.cpu_count()
		self.idfFiles = []
		self.tasks = []

	##
	## @brief      This method get all idf files in the folder passed as 
	##             argument that were been created by EPlusPlus (see 
	##             "getIDFFIles" documentation for more info.) After check
	##             what is the current OS, will iterate by each idf file
	##             creating a string formated, that later will be interpreted
	##             as a task by the subprocesses. At the end just append the
	##             task in a list. Finally, set the attibute "tasks" to the
	##             new list that we just created.
	##
	## @param      self             Non static method.
	## @param      platformManager  Used to check what is the current OS.
	## @param      pathToEpw        The path to epw file.
	## @param      pathToFolder     The path to folder that has the IDF files
	##                              generated by the EPlusPlus.
	## @param      fileManager      File maanger used to filter the IDF files.
	##
	## @return     This is a void method.
	##
	def createTasks(self, platformManager, pathToEpw, pathToFolder, fileManager):
		self.idfFiles = fileManager.getIDFFiles(pathToFolder)
		tasks = []
		processes = []

		if platformManager.isWindows():
			for i in range(0, len(self.idfFiles)):
				idfFile = self.idfFiles.pop()
				absPath = str(pathToFolder) +"/" + str(idfFile)
				output = absPath[:-4]
				cmd = "C:/EnergyPlusV8-7-0/energyplus.exe -w {} -d {} -r {}"
				cmd = cmd.format(pathToEpw, output, absPath)
				tasks.append([cmd])
		elif platformManager.isLinux():
			for i in range(0, len(self.idfFiles)):
					idfFile = self.idfFiles.pop()
					absPath = str(pathToFolder) + "/" + str(idfFile)
					output = absPath[:-4]
					cmd = "runenergyplus -w {} -d {} -r {}"
					cmd = cmd.format(pathToEpw, output, absPath)
					tasks.append(cmd)

		self.tasks = tasks

	##
	## @brief      This method create tasks to be executed. After that, 
	##             will iterate in a while loop until no more tasks remaing.
	##             In each iteration, will execute the tasks in the 
	##             "runEplus" method (see its documentation for more info).
	##
	## @param      self             Non static method
	## @param      platformManager  Used to check what is the current OS.
	## @param      pathToEpw        The path to epw file.
	## @param      pathToFolder     The path to folder that has the IDF files
	##                              generated by the EPlusPlus.
	## @param      fileManager      File maanger used to filter the IDF files.
	##
	## @return     This is a void method.
	##
	def executeTasks(self, platformManager, pathToEpw, pathToFolder, fileManager):
		self.createTasks(platformManager, pathToEpw, pathToFolder, fileManager)

		while len(self.tasks) > 0:
			self.runEPlus()
	
	##
	## @brief      This method creates a for loop that iterate so many times
	##             as the number of CPU's. For each iteration, it will remove
	##             a task from the tasks list and create a subprocess to 
	##             execute that task. The processes list has all processes
	##             created and at the end of method we iterate through this 
	##             list so we can wait until all subprocesses finish.
	##
	## @param      self  Non static method
	##
	## @return     This is a void method
	##
	def runEPlus(self):
		processes = []
		for i in range(0, self.numCores):
			try:
				task = self.tasks.pop()
			except Exception as e:
				continue
			if task:
				process = subprocess.Popen([task], shell=False)
				processes.append(process)

		for process in processes:
			process.wait()

		del processes